#!/usr/bin/env python3.10

import re
import select
from socket import socket, AF_INET, SOCK_STREAM
import sys
import _thread
import time

BUFFER_SIZE = 1040000
server_port = 8080
clrf = "\r\n\r\n"
cl = "\r\n"
bitrate_array = []


#def io_select(sock, _input):
#    """
        
#    """
#    while True:
#        inputs = [sock]
#        readable, writable, exceptional = select.select(inputs, inputs, inputs, 1)
#        if (_input and readable) or ((not _input) and writable):
#            return True
#        elif exceptional:
#            return None


def recv_http_message(sock):
    header = b''
    body = b''
    is_header = True
    content_length = 0
    while True:
        cur = sock.recv(BUFFER_SIZE)
        if not cur:
            return "", 0

        if is_header:
            header += cur
        else:
            body += cur
        if clrf.encode() in header:
            splited = header.split(clrf.encode())
            header, body = splited[0], splited[1]
            is_header = False
            lines = header.split(cl.encode())
            for line in lines:
                if b"Content-Length" in line:
                    content_length = int(line.split(b" ")[1])
            if not content_length or len(body) >= content_length:
                return header + clrf.encode() + body, content_length
        
        if not is_header and len(body) >= content_length:
            return header + clrf.encode() + body, content_length



def get_bitrate(bitrate_array, avg_tput):
    if not bitrate_array:
        return 40000
    for r in bitrate_array:
        if avg_tput/r >= 1.5:
            return rate
    return min(bitrate_array)*1.5
    
	
def get_path(_message):
    """
    """
    lines = _message.split(cl.encode())
    return lines[0].split(b" ")[1]


def run(log, alpha, proxy_sock, fake_ip, server_ip, server_port):
    to_server_socket = socket(AF_INET, SOCK_STREAM)
    to_server_socket.bind((fake_ip, 0))
    to_server_socket.connect((server_ip, server_port))

    avg_tput = -1
    manifest = False
    opt_bitrate = -1
    
    print("Starting Connection")
    while True:
        # get message

        #if not io_select(proxy_sock, 1): # the select is not required (work the same without) but it's goo practice..
        #    break
        message, content_length = recv_http_message(proxy_sock)

        print("\nstart\n")
        if not message:
            break

        if b"mpd" in get_path(message):
            manifest = True
        elif opt_bitrate != -1 and b"BigBuckBunny" in get_path(message):
            r = re.search(b"\\d+", message)
            message = message[:int(r.start())] + str(bitrate) + message[int(r.end()):]

        t_s = time.time()
        #if not io_select(to_server_socket, 0):
        #    break
        if isinstance(message, str):
            message = message.encode()
        to_server_socket.send(message)
        #if not io_select(to_server_socket, 1):
        #    break
        response, content_length = recv_http_message(to_server_socket)
        t_f = time.time()
        if not response:
            break

        duration = (t_f - t_s)
        tput = len(response) * 8 / duration
        tput = tput / 1e3
        if avg_tput != -1:
            avg_tput = alpha * tput + (1 - alpha) * avg_tput
        else:
            avg_tput = tput
        if bitrate_array:
            opt_bitrate = get_bitrate(bitrate_array, avg_tput)

        chunk_name = get_path(message)

        rgx = re.search(b"\d+", message)
        bitrate = int(message[int(rgx.start()): int(rgx.end())])

        log_line = f"{str(time.time())} {str(duration)} {str(tput)} {str(avg_tput)} {str(bitrate)} " \
                   f"{str(server_ip)} {str(chunk_name)}"
        log.write(log_line + '\n')
        print(f"writing to file: {log_line}\n")

        if manifest:
            manifest = False
            print("Getting manifest")
            print("before: ", message)
            message = message.replace(b"BigBuckBunny_6s.mpd", b"BigBuckBunny_6s_nolist.mpd")
            print("After: ", message)
            if isinstance(message, str):
                message = message.encode()
            to_server_socket.send(message)
            response, content_length = recv_http_message(to_server_socket)

        #if not io_select(proxy_sock, 0):
        #    break
        if isinstance(response, str):
            response = response.encode()
        proxy_sock.send(response)

        print("\nend\n")
    proxy_sock.close()
    to_server_socket.close()
    print("Closing Connection....")


if __name__ == '__main__':
    log = sys.argv[1]
    alpha = float(sys.argv[2])
    proxy_listen_port = int(sys.argv[3])
    fake_ip = sys.argv[4]
    server_ip = sys.argv[5]

    proxy_socket = socket(AF_INET, SOCK_STREAM)
    try:
        proxy_socket.bind(('', proxy_listen_port))
        proxy_socket.listen(10)
        log = open(log, "w")
    except Exception as e:
        print(f"Error: {e}")
        proxy_socket.close()
        exit(1)

    print("Proxy is ready...")

    while True:
        try:
            client_socket, addr = proxy_socket.accept()
            _thread.start_new_thread(run, (log, alpha, client_socket, fake_ip, server_ip, server_port))
        except KeyboardInterrupt:
            client_socket.close()
            proxy_socket.close()
            log.close()


